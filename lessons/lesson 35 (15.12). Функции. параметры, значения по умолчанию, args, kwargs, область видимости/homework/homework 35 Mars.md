# Домашняя работа: Функции. Параметры, значения по умолчанию, args, kwargs, область видимости

## Задачи

1.  **Функция для расчета стоимости доставки**
    -   **Описание задачи:** Ты работаешь над модулем для интернет-магазина. Нужно создать функцию, которая рассчитывает стоимость доставки. Функция должна принимать обязательные параметры (город и вес) и один необязательный параметр со значением по умолчанию (срочность доставки). Это упражнение закрепит понимание объявления функций, передачи позиционных и именованных аргументов, а также использования оператора `return`.
    -   **Пример (вход → выход):**
        -   `calculate_delivery("Москва", 5) → 400` (стандартная доставка: 300 + 20*5)
        -   `calculate_delivery("Казань", 2, urgent=True) → 560` (срочная доставка: 500 + 30*2)
        -   `calculate_delivery(weight=1, city="Сочи") → 320` (стандартная доставка, аргументы переданы по имени)
    -   **Критерии проверки и ограничения:**
        -   Функция должна называться `calculate_delivery`.
        -   Параметры в порядке объявления: `city` (строка), `weight_kg` (число), `urgent` (логическое значение, по умолчанию `False`).
        -   Формула расчета: если `urgent` равен `True`, стоимость = `500 + 30 * weight_kg`. Иначе стоимость = `300 + 20 * weight_kg`.
        -   Функция должна возвращать число (результат расчета), а не печатать его.
    -   **Решение (псевдокод):**
        1.  Объяви функцию `calculate_delivery` с тремя параметрами: `city`, `weight_kg`, `urgent` (последнему задай значение по умолчанию `False`).
        2.  Внутри функции создай условие: если `urgent` истинно (`True`).
        3.  Если условие верно, вычисли результат по формуле для срочной доставки.
        4.  Иначе (если `urgent` ложно), вычисли результат по формуле для стандартной доставки.
        5.  Используй оператор `return`, чтобы вернуть вычисленный результат.
    -   **Рекомендации:**
        -   **PEP8:** Имя функции должно быть в `snake_case` (все буквы строчные, слова разделены подчеркиванием). После запятой в списке параметров ставь пробел.

2.  **Безопасное добавление заметок в список**
    -   **Описание задачи:** Ты пишешь функцию для ведения списка дел. Важно, чтобы при каждом вызове функции без передачи списка создавался новый пустой список, а не использовался один и тот же. Это упражнение научит безопасно работать с изменяемыми типами данных (списками) в качестве значений по умолчанию, используя паттерн с `None`.
    -   **Пример (вход → выход):**
        -   `add_note("Купить молоко") → ['Купить молоко']`
        -   `add_note("Позвонить маме") → ['Позвонить маме']` (Важно: это должен быть новый список, а не продолжение предыдущего!)
        -   `my_list = ["Задача 1"]; add_note("Задача 2", my_list) → ['Задача 1', 'Задача 2']`
    -   **Критерии проверки и ограничения:**
        -   Функция должна называться `add_note`.
        -   Параметры: `note` (строка, новая заметка) и `notes_list` (список, по умолчанию `None`).
        -   Если `notes_list` равен `None`, внутри функции нужно создать новый пустой список.
        -   Добавь новую заметку `note` в список `notes_list`.
        -   Функция должна возвращать обновленный список.
    -   **Решение (псевдокод):**
        1.  Объяви функцию `add_note` с параметрами `note` и `notes_list` (значение по умолчанию — `None`).
        2.  Внутри функции проверь, равен ли `notes_list` `None`.
        3.  Если равен, создай новый пустой список и присвой его переменной `notes_list`.
        4.  Добавь (`append`) строку `note` в список `notes_list`.
        5.  Верни (`return`) список `notes_list`.
    -   **Рекомендации:**
        -   Для проверки на `None` используй оператор `is`: `if notes_list is None:`.
        -   **PEP8:** Используй отступ в 4 пробела для тела функции и блоков `if`.

3.  **Функция-агрегатор для подсчета суммы и среднего**
    -   **Описание задачи:** Нужно создать универсальную функцию, которая может принимать любое количество чисел и возвращать их сумму и среднее арифметическое. Это упражнение познакомит с использованием `*args` для работы с переменным числом аргументов.
    -   **Пример (вход → выход):**
        -   `sum_and_mean(10, 20, 30) → (60, 20.0)` (сумма 60, среднее 20.0)
        -   `sum_and_mean(5) → (5, 5.0)`
        -   `sum_and_mean() → (0, 0)` (обрати внимание на обработку случая без аргументов!)
    -   **Критерии проверки и ограничения:**
        -   Функция должна называться `sum_and_mean`.
        -   Используй параметр `*args` для приема произвольного количества чисел.
        -   Функция должна возвращать кортеж из двух чисел: (сумма, среднее).
        -   Если аргументов не передано (`args` пуст), сумма и среднее должны быть равны 0.
        -   Избегай ошибки деления на ноль.
    -   **Решение (псевдокод):**
        1.  Объяви функцию `sum_and_mean` с параметром `*args`.
        2.  Посчитай сумму всех чисел в `args`. Встроенная функция `sum()` работает с коллекциями.
        3.  Определи количество переданных чисел — длину `args`.
        4.  Если количество больше 0, вычисли среднее: сумма / количество.
        5.  Если количество равно 0, среднее равно 0.
        6.  Верни (`return`) кортеж: (сумма, среднее).
    -   **Рекомендации:**
        -   `*args` внутри функции является кортежем. Для подсчета количества элементов используй `len(args)`.
        -   **PEP8:** Параметр `*args` — это общепринятое имя. Менять его не нужно.

4.  **Локальный счетчик и глобальная настройка**
    -   **Описание задачи:** Создай программу с двумя функциями. Одна функция использует локальную переменную для подсчета своих вызовов, а другая изменяет глобальную переменную-настройку. Это упражнение поможет разобраться в областях видимости (локальная vs. глобальная) и использованию ключевого слова `global`.
    -   **Пример выполнения кода:**
        ```python
        print(get_config())  # Начальное значение: "low"
        set_config("high")
        print(get_config())  # Теперь: "high"

        print(track_local())  # Вывод: 1
        print(track_local())  # Вывод: 2 (счетчик увеличивается)
        # print(local_counter)  # Эта строка вызовет ошибку! Переменная local_counter здесь не видна.
        ```
    -   **Критерии проверки и ограничения:**
        -   Объяви глобальную переменную `APP_CONFIG` со значением `"low"`.
        -   Функция `get_config()` должна просто возвращать текущее значение `APP_CONFIG`.
        -   Функция `set_config(new_value)` должна изменять глобальную переменную `APP_CONFIG` на `new_value`. Используй `global`.
        -   Функция `track_local()` должна содержать локальную переменную `call_count`, которая увеличивается на 1 при каждом вызове. Функция возвращает текущее значение `call_count`.
    -   **Решение (псевдокод):**
        1.  В начале программы создай глобальную переменную `APP_CONFIG = "low"`.
        2.  Объяви функцию `get_config()` без параметров. Внутри просто верни (`return`) значение `APP_CONFIG`.
        3.  Объяви функцию `set_config(new_value)`.
            -   Первой строкой внутри функции укажи, что будешь использовать глобальную переменную `APP_CONFIG`.
            -   Присвой глобальной переменной `APP_CONFIG` значение `new_value`.
        4.  Объяви функцию `track_local()`.
            -   Внутри функции создай локальную переменную `call_count`. **Важно:** Чтобы она сохраняла значение между вызовами, инициализируй ее как `0` только если она еще не существует (подумай, как это можно сделать, используя область видимости).
            -   Увеличь `call_count` на 1.
            -   Верни значение `call_count`.
    -   **Рекомендации:**
        -   Для `track_local()` тебе понадобится объявить `call_count` как `nonlocal` или использовать другой подход, так как это локальная переменная. Подсказка: можно использовать изменяемый объект, объявленный во внешней области видимости функции `track_local`, но не в глобальной (например, создать еще одну внешнюю функцию-обертку). Это задание продвинутого уровня из блока "Замыкание". Если это сложно, сосредоточься на первых трех задачах.
        -   **PEP8:** Глобальные переменные, если они необходимы, должны быть объявлены в самом начале модуля и записаны заглавными буквами с подчеркиваниями (UPPER_CASE).
